数据类型决定了程序中 数据 和 操作 的意义

### 基本内置类型
- 算术类型arithmetic type——分为 **整型integral type** 和 **浮点型**
  - 字符
  - 整数
  - 布尔类型：取值为true/false
  - 浮点数
  - signed 与 unsigned
- 空类型 void
  - 不对应具体的值，仅用于特殊场合。
  - 例如：当函数值不返回任何值时，返回void类型
- 类型转换
  - 类型所能表示的值的范围决定了转换的过程
  - 特殊情况：给带符号类型赋了一个超出它表示范围的值，结果是undifined
    - 程序可能继续工作
    - 崩溃
    - 产生垃圾数据
- 字面值常量litreal
  - 整型和浮点型literal ： 24 / 024 / 0x24 // 3.14159 / 3.14159E0 / 0. / 0e0 / .001
  - 字符和字符串literal ： 'a' / "hello!"
  - 转义序列：有两类字符不可直接使用1.不可打印的字符(退格) 2.c++中特殊含义的字符(' " ? \)  需要用到转义字符
  - 指定字面值的类型
  - bool字面值 true/false  和 pointer字面值**nullptr**

___
### 变量
- 变量定义
  - 初始化 VS 赋值
    - 初始化initialized：创建一个变量时赋予其一个初始值
    - 赋值：把对象当前值擦除，用一个新值代替
  - 列表初始化： 初始化有4种方式，列表初始化是其中两种
```c++
        int a = 0;
        int a = {0};
        int a{0}; //用花括号初始化：列表初始化
        int a(0);
        //当用于内置类型初始化时，列表初始化有一个特点： 如果用列表初始化，且初始值存在丢失信息的风险，编译器会报错
        long double ld = 3.1415926536;
        int a{ld}, b = {ld}; //错误：转换未执行，因为存在丢失信息风险
        int c(ld), d = ld;   //正确：转换执行，且存在丢失信息风险
```
  - 默认初始化；定义变量时未指定初值，则变量被default initialized
    - 内置类型：定义位置在函数体之外：默认初始化0 
      - 一种例外情况：定义在函数体内部的内置类型变量将不被初始化，拷贝或访问将报错
    - 每个类各自决定其对象的初始化方式
- 变量声明 vs 变量定义
- 标识符identifier ： 由字母、数字、下划线组成，必须以字母、下划线开头
  - 变量命名规范
- 名字的作用域

### 复合类型

### const限定符

### 处理类型

### 自定义数据结构