#### 迭代写法 :需要重新看视频
```c++
class Solution {
public:
//把以head为头节点的链表翻转过来，并返回原来链表的尾节点【反转后的头节点】
    ListNode* reverseList(ListNode* head) {
        ListNode* prev = NULL;  //创建额外空间存前驱节点
        ListNode* cur = head;  //当前指针cur初始化指向head

        while (cur)
        {
            ListNode* next = cur->next;  //用一个next先存好cur的next
            cur->next = prev;  //把当前指针的next指向prev前驱节点
            prev = cur, cur = next;  //往后进一格
        }
        return prev;  
    }
};
```

#### 递归写法
```c++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (!head || !head->next) return head;
        ListNode *tail = reverseList(head->next);
        head->next->next = head; //head->next反转后变成最后一个点，它后面接head
        head->next = nullptr; //此时head是最后一个节点，head->next指向空指针
        return tail;
    }
};
```