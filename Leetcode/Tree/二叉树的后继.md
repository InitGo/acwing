### 285二叉搜索树中的中序后继（无parent版）
- [题目链接](https://leetcode.cn/problems/P5rCT8/)
- 题意：给定一棵二叉搜索树和其中的一个节点 p ，找到该节点在树中的中序后继。如果节点没有中序后继，请返回 null 。
节点 p 的后继是值比 p.val 大的节点中键值最小的节点，即按中序遍历的顺序节点 p 的下一个节点。

1:暴力算法
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<TreeNode*> inorder;
    TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) {
        dfs(root);
        int n = inorder.size();
        for (int i = 0; i < n; i ++ ) {
            auto x = inorder[i];
            if (x == p) {
                if (i < n - 1) return inorder[i + 1];
                else return NULL;
            }
        }
        return NULL;
    }
    void dfs(TreeNode* root) {
        if (!root) return;
        dfs(root->left);
        inorder.push_back(root);
        dfs(root->right);
    }
};
```

2:利用二叉搜索树的特性
- **思路:反向考虑:可能的答案在什么位置, 哪半边绝对不可能是潜在的答案**
- 整体上是自然的思考方式
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) {
        if (!root) return NULL;
        if (p->right) {
            p = p->right;
            while (p->left) p = p->left;
            return p;
        }

        auto node = root; //用node遍历整颗树[代替root,实际上用root完全ok]
        TreeNode* ans = NULL;  //答案初始化为null
        while (node) {
            if (node->val > p->val) {  //如果目标节点值小于当前节点值,则可能的答案是当前点或在左子树中 (考虑中序遍历时,有序的状态 左中右)
                ans = node; //先存下可能的答案root
                node = node->left;  //node转移到左子树中,缩小node范围
            } else {  //如果目标节点值>=当前节点值,则当前点和左子树绝不可能变成答案,去右子树中搜索
                node = node->right;  
            }
        }
        return ans;
    }
};
```



### 二叉树的下一个节点（有mother版）
- [题目链接](https://www.acwing.com/problem/content/description/31/)
- 题意：
  - 给定一棵二叉树的其中一个节点，请找出中序遍历序列的下一个节点。
  - 注意：如果给定的节点是中序遍历序列的最后一个，则返回空节点;二叉树一定不为空，且给定的节点一定不是空节点；
```C++

;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode *father; !!!!!!!!!!!!
 *     TreeNode(int x) : val(x), left(NULL), right(NULL), father(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* inorderSuccessor(TreeNode* p) {
        if (p->right) {  //如果p有右子树,则去找右子树的最左点
            p = p->right;
            while (p->left) p = p->left;
            return p;
        }
        
        //如果p没有右子树,往上找
        //如果p的上一个点存在 && 当前点是上一个点的左子树,则上一个点就是答案 先左子树再上一个点再右子树
        //如果p的上一个点存在 && 当前点是上一个点的右子树,则让当前点迭代到上一个节点,循环做
        while (p->father && p == p->father->right) p = p->father;
        return p->father;
    }
};
```