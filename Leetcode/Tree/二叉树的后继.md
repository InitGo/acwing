### 二叉搜索树中的中序后继（无mother版）
- [题目链接](https://leetcode.cn/problems/P5rCT8/)
- 题意：给定一棵二叉搜索树和其中的一个节点 p ，找到该节点在树中的中序后继。如果节点没有中序后继，请返回 null 。
节点 p 的后继是值比 p.val 大的节点中键值最小的节点，即按中序遍历的顺序节点 p 的下一个节点。

暴力算法
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<TreeNode*> inorder;
    TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) {
        dfs(root);
        int n = inorder.size();
        for (int i = 0; i < n; i ++ ) {
            auto x = inorder[i];
            if (x == p) {
                if (i < n - 1) return inorder[i + 1];
                else return NULL;
            }
        }
        return NULL;
    }
    void dfs(TreeNode* root) {
        if (!root) return;
        dfs(root->left);
        inorder.push_back(root);
        dfs(root->right);
    }
};
```



### 二叉树的下一个节点（有mother版）
- [题目链接](https://www.acwing.com/problem/content/description/31/)
- 题意：
  - 给定一棵二叉树的其中一个节点，请找出中序遍历序列的下一个节点。
  - 注意：如果给定的节点是中序遍历序列的最后一个，则返回空节点;二叉树一定不为空，且给定的节点一定不是空节点；
```C++
;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode *father; !!!!!!!!!!!!
 *     TreeNode(int x) : val(x), left(NULL), right(NULL), father(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* inorderSuccessor(TreeNode* p) {
        if (p->right) {
            p = p->right;
            while (p->left) p = p->left;
            return p;
        }
        
        while (p->father && p == p->father->right) p = p->father;
        return p->father;
    }
};
```