### 算法1 (查找路径) O(n)
分别找出根节点到两个节点的路径，则最后一个公共节点就是最低公共祖先了。
时间复杂度分析：需要在树中查找节点，复杂度为O(n)
```c++
class Solution {
public:
    int findPath(TreeNode*root, TreeNode* p, vector<TreeNode*>&path){
        if(!root)
            return 0;
        if(root->val==p->val){
            path.push_back(root);
            return 1;
        }
        int l = findPath(root->left,p,path);
        int r = findPath(root->right,p,path);
        if(l==1||r==1)
            path.push_back(root);
        return l==1||r==1;
    }
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        vector<TreeNode*>path1,path2;
        findPath(root,p,path1);
        findPath(root,q,path2);
        if(path1.empty()||path2.empty())
            return NULL;
        TreeNode* res =NULL;
        for(int i = 0;i<path1.size();i++){
            if(i>=path1.size()||i>=path2.size())
                break;
            if(path1[path1.size()-1-i]==path2[path2.size()-1-i])
                res = path1[path1.size()-1-i];
            else
                break;
        }
        return res;
    }
};
```

### 算法2 (递归) O(n)
考虑在左子树和右子树中查找这两个节点/查找最近公共祖先
- 如果两个节点分别位于左子树和右子树，则最低公共祖先为自己(root)
- 若左子树中两个节点都找不到，说明最低公共祖先一定在右子树中，反之亦然。
- 考虑到二叉树的递归特性，因此可以通过递归来求得。

时间复杂度分析：需要遍历树，复杂度为 O(n)

```c++
class Solution {
public:
    //去root下找p或者q，找到了就返回p或者q，找不到就返回NNULL
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (!root) return NULL;  //如果是空节点，说明没有p和q， 返回NULL
        if (root == p || root == q)  return root; 
        //情况1：若p就是root， q在p所在子树下， 则返回p，即返回root
        //情况2：若p就是root，q不在p所在子树下，则返回p本身，即返回root
        
        //去左右子树分别找p或q。看看有没有找到
        auto left = lowestCommonAncestor(root->left, p, q);
        auto right = lowestCommonAncestor(root->right, p, q);
        if (left && right) return root; //如果左右子树都有p或者q，说明root就是要找的最近公共祖先
        
        // if (left) return left; //如果left有p或者q，right没有，则返回左子树
        // return right; //否则left和right都为空，随便返回一个
        
        if (left == NULL) return right; //如果左子树中找不到两个点，说明LCA一定在右子树
        return left; //否则left和right都为空，随便返回一个
    }
};
```
