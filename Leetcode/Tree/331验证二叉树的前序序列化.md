### 题目描述
一种把二叉树序列化的方式是使用前序遍历。当我们遇到非空节点时，直接记录它的值；当我们遇到空节点时，记录`#`。
```
     _9_
    /   \
   3     2
  / \   / \
 4   1  #  6
/ \ / \   / \
# # # #   # #
```
例如，上述二叉树可以被序列化成`"9,3,4,#,#,1,#,#,2,#,6,#,#"`，`#`表示空节点。

给定一个用逗号隔开的序列，请判断它是不是一个合法的二叉树前序遍历。请不要将二叉树重建出来。

被逗号隔开的值要么是整数，要么是`#`。

给定的序列一定是合法的。例如，不会出现两个连续逗号的情况：`1,,3`。

### 样例1
```
输入："9,3,4,#,#,1,#,#,2,#,6,#,#"
输出：true
```
### 样例2
```
输入："1,#"
输出：false
```
### 样例3
```
输入："9,#,#,1"
输出：false
```


## 算法1
**(二叉树遍历)** $O(n)$
一般来说，只给出前序遍历，并不能唯一确定一棵二叉树。但这道题目中还给出了所有空节点的位置，所以可以唯一确定一棵二叉树。
**用模拟法，模拟二叉树的先序遍历过程。**
我们用先根顺序递归遍历整棵树，遍历时用一个指针在给定数组中指向当前节点的值，如果遇到#，则说明遇到了空节点，直接`return`；如果遇到整数，说明遍历到了树中的一个节点，我们先将指针后移，表示先输出根节点，然后依次递归遍历左子树和右子树。
如果递归还没结束但数组已经遍历完，或者递归结束但数组还没遍历完，则说明给定的序列不是一个合法的前序遍历。

时间复杂度分析：递归遍历时只将数组扫描了一遍，所以时间复杂度是 $O(n)$。

### C++ 代码
```c++
class Solution {
public:
    bool ans = true; //全局变量存答案
    bool isValidSerialization(string preorder) {
        preorder += ','; //在结尾添加逗号，方便后面判断
        int u = 0; //指针，遍历树用
        dfs(preorder, u); //模拟 先序遍历这棵树
        return ans && u == preorder.size(); //最后ans为true，而且preorder用完，没有多余的
    }

    void dfs(string &preorder, int &u)
    {
        if (u == preorder.size()) ////先检查u有没有出界，遍历应当是有东西的，这里preorder用完了，说明失败
        {
            ans = false;
            return;
        }
        if (preorder[u] == '#') //如果当前点是空节点，则返回，并且指针指向下一个
        {
            u += 2;
            return;
        }
        //当前节点不是空节点，ex. 123 ，则while走完整个数字
        while (preorder[u] != ',') u ++ ; 
        u ++ ; //走完逗号
        dfs(preorder, u); //遍历左子树
        dfs(preorder, u); //遍历右子树
    }
};
```

## 算法2
二叉树性质：任意二叉树，叶子节点数=$n_0$，度为2的节点数=$n_2$，则$n_0 = n_2 + 1$
思路：空节点（#）比非空节点数量多1，可以用栈来判断，每次遇到非空节点，栈内元素加1， 遇到空节点栈内元素减1。当遇到空节点且此时栈已经是空栈时，该节点必是最后一个节点，否则该序列不是二叉树的前序遍历。
```c++
class Solution {
public:
    bool isValidSerialization(string preorder) {
        stack<int> stk;
        int len = preorder.size();

        for (int i = 0; i < len; i ++ ) {
            if (preorder[i] == '#') { //如果遇到的是空节点
                //如果遇到了空节点，且栈为空，则该空节点应当是最后一个节点，否则失败
                if (stk.empty()) return i == len - 1;
                //如果遇到了空节点，且栈不为空，则pop栈顶
                else {
                    stk.pop();
                    i ++ ; //#后面的逗号略掉
                }
            }
            else { //如果遇到的是数字(非空节点) ex.123
                // 用逗号隔开的数字可能不止一位数，用while走完整个数字
                stk.push(0); //填充
                while (i < len && preorder[i] != ',') i ++ ; 
            }
        }
        return false; //一整个preorder做完，但是没有返回true，失败
    }
};
```