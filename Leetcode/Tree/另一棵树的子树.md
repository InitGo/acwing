
###子树

- 题意解释：一定是子树的形式，不可以在中间出现相同的结构

- 子树：二叉树 tree 的一棵子树包括 tree 的某个节点和这个节点的所有后代节点
- 子结构：B是A的子结构， 即A中有出现和B相同的结构和节点值。

- 算法1：dfs递归遍历，暴力检查

 ```c++
class Solution {
public: 
    bool check(TreeNode* p, TreeNode* q)  //检查两棵树是否完全相同
    {
        if (!p && !q) return true;
        if (!p || !q || p->val != q->val) return false;
        return check(p->left, q->left) && check(p->right, q->right);
    }
    bool isSubtree(TreeNode* root, TreeNode* subRoot) {
        if (!root) return !subRoot;
        return check(root, subRoot) || isSubtree(root->left, subRoot) || isSubtree(root->right, subRoot);
        //两棵树是否完全相同？ 左子树是否包含子树？ 右子树是否包含子树？
    }
};
```

- 算法2：树哈希

```c++
class Solution {
public:
    const int P = 131, Q = 157, MOD = 1e7 + 7;
    int T = -1;
    bool ans = false;  //t是否在s中出现过

    int dfs(TreeNode* root) {
        if (!root) return 12345;  //如果根节点为空，返回一个能与0子树区分开的数字，表示空
        int left = dfs(root->left), right = dfs(root->right);  //左右子树的哈希值
        int x = (root->val % MOD + MOD) % MOD;  //根节点的值【模加模，保证整数】
        if (left == T || right == T) ans = true;
        return (x + left * P % MOD + right * Q % MOD) % MOD;
    }

    bool isSubtree(TreeNode* s, TreeNode* t) {
        T = dfs(t);  //求一下t的哈希值
        if (T == dfs(s)) ans = true;  //如果t的哈希值==s的哈希值 
        return ans;
    }
};
```
