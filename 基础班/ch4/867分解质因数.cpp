//https://www.acwing.com/activity/content/problem/content/936/

#include <iostream>
#include <algorithm>

using namespace std;

void divide(int n)
{
	// 可以证明 在 1 ~ n 中大于sqrt(n)的质因子最多只有一个。
    /* 用 反证法 假设在 1 ~ n 中大于sqrt(n)的质数有两个，那么这两个数的乘积一定大于 n ，显然这与在 1 ~ n 中这个条件不成立。
       所以在 1 ~ n 中大于sqrt(n)的质因子最多只有一个。
       本来我们需要从 2 枚举到 n ，这里我们同样可以对它进行优化，先枚举到 n / i ，即先找到sqrt(n) 中的所有质因子，最后再去判断是否存在大于sqrt(n)的质因子
    */
    for (int i = 2; i <= n / i; i ++ )
    {
        if(n % i == 0)//如果 n % i == 0 的话，它就保证 n 中已经没有了 1 ~ i - 1 的因子，同样也保证了 i 中也没有了1 ~ i - 1 的因子
        {             //这样就保证了 i 一定是一个质数，同样 i 一定是 n 的一个质因子  
            int s = 0;//用 s 来记录指数的次数
            while(n % i == 0)//把 i 除完了， n 中已经没有 i 的质因子了，对于后面含有 i 的素因子的合数，也就再也不能被 n 整除了
            {                //而根据唯一分解定理，每一个合数都能表示成素因子乘积的形式
                             //所以再筛到这个合数的之前，它的素因子必定已经被除完了，所以就不会筛到合数。
                s++;
                n /= i;    //把 n 缩小到 n / i, 就相当于再对 n / i 这个数进行质因数分解 
            }
            printf("%d %d\n", i, s);//输出质因数 i 和它的指数 s
        }
    }
    if(n != 1)printf("%d 1\n",n);
    //如果最后剩下的那个数不等于1的话，那么这个数就是那个大于sqrt(n)的那个质数，或者 n 本身就是一个质数	
    
}
//假如 i 是一个合数，那么它一定可以分解成多个质因子相乘的形式，
//这多个质因子同时也是 a 的质因子且比 i 要小，
//而比 i 小的数在之前的循环过程中一定是被条件除完了的
//所以 i 不可能是合数，只可能是质数

int main()
{
    int n;
    cin >> n;
    while (n -- )
    {
        int x;
        cin >> x;
        divide(x);
    }

    return 0;
}