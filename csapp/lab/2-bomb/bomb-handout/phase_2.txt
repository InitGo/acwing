   phase_2
   0x0000000000400efc <+0>:     push   %rbp
   0x0000000000400efd <+1>:     push   %rbx
   0x0000000000400efe <+2>:     sub    $0x28,%rsp  //分配0x28B的空间
   0x0000000000400f02 <+6>:     mov    %rsp,%rsi  //caller save
   0x0000000000400f05 <+9>:     callq  0x40145c <read_six_numbers>
   0x0000000000400f0a <+14>:    cmpl   $0x1,(%rsp)  //这里检查0x0位置是否是1
   0x0000000000400f0e <+18>:    je     0x400f30 <phase_2+52> //这里必须跳转 读入数字完成，开始匹配？
   0x0000000000400f10 <+20>:    callq  0x40143a <explode_bomb>  //爆炸
   0x0000000000400f15 <+25>:    jmp    0x400f30 <phase_2+52>

   0x0000000000400f17 <+27>:    mov    -0x4(%rbx),%eax //eax 存 0地址 处的数字   
   0x0000000000400f1a <+30>:    add    %eax,%eax // 0位置的数字*2 == 答案数字1    eax加完以后等于2
   0x0000000000400f1c <+32>:    cmp    %eax,(%rbx)
   0x0000000000400f1e <+34>:    je     0x400f25 <phase_2+41> //如果第一个数字匹配
   0x0000000000400f20 <+36>:    callq  0x40143a <explode_bomb>
   0x0000000000400f25 <+41>:    add    $0x4,%rbx // r8
   0x0000000000400f29 <+45>:    cmp    %rbp,%rbx //检查数组是否到末尾
   0x0000000000400f2c <+48>:    jne    0x400f17 <phase_2+27>  //还没到数组结尾

   0x0000000000400f2e <+50>:    jmp    0x400f3c <phase_2+64>  //顺利结束
   0x0000000000400f30 <+52>:    lea    0x4(%rsp),%rbx  // rbx存第一个数
   0x0000000000400f35 <+57>:    lea    0x18(%rsp),%rbp //rbp存最后一个数
   0x0000000000400f3a <+62>:    jmp    0x400f17 <phase_2+27>  //跳转
   0x0000000000400f3c <+64>:    add    $0x28,%rsp
   0x0000000000400f40 <+68>:    pop    %rbx
--Type <RET> for more, q to quit, c to continue without paging--
   0x0000000000400f41 <+69>:    pop    %rbp
   0x0000000000400f42 <+70>:    retq   



Dump of assembler code for function read_six_numbers:
   0x000000000040145c <+0>:     sub    $0x18,%rsp  //分配24B空间，正好对应6个int
   0x0000000000401460 <+4>:     mov    %rsi,%rdx  //用rdx存0x0地址
   0x0000000000401463 <+7>:     lea    0x4(%rsi),%rcx //用rcx存0x4地址
   0x0000000000401467 <+11>:    lea    0x14(%rsi),%rax //rax存0x14地址 第五个数字的 第一个/最后一个？ 某个字节
   0x000000000040146b <+15>:    mov    %rax,0x8(%rsp) //0x20地址处 存 0x14
   0x0000000000401470 <+20>:    lea    0x10(%rsi),%rax
   0x0000000000401474 <+24>:    mov    %rax,(%rsp) // 0x18地址处存 0x10
   0x0000000000401478 <+28>:    lea    0xc(%rsi),%r9 //r9存0xc
   0x000000000040147c <+32>:    lea    0x8(%rsi),%r8 //r8存 0x8
   0x0000000000401480 <+36>:    mov    $0x4025c3,%esi 
   0x0000000000401485 <+41>:    mov    $0x0,%eax
   0x000000000040148a <+46>:    callq  0x400bf0 <__isoc99_sscanf@plt>  ///////
   0x000000000040148f <+51>:    cmp    $0x5,%eax  //计算读入的数字的长度 
   0x0000000000401492 <+54>:    jg     0x401499 <read_six_numbers+61>
   0x0000000000401494 <+56>:    callq  0x40143a <explode_bomb>
   0x0000000000401499 <+61>:    add    $0x18,%rsp //长度合适， 正常返回
   0x000000000040149d <+65>:    retq