
## 4865. 有效类型
在本题中，关于有效类型字符串，具体定义如下：

- `int` 是有效类型字符串。
- 如果字符串 `X` 和字符串 `Y` 都是有效类型字符串，则 `pair<X,Y>` 是有效类型字符串。

现有一行若干个单词，每个单词要么是 `pair`，要么是 `int`，并且其中 `int` 的数量恰好为$n$个。

你可以在不改变单词顺序的前提下，在这一行中任意添加 `<`、`>`、`,` 符号。

你的任务是构造出一个有效类型字符串。

输出这个有效类型字符串。

注意：

1. 有效类型字符串中**不含**空格或其它多余字符。
2. 可以证明如果存在满足条件的有效类型字符串，那么它一定是唯一的。
3. 如果不存在满足条件的有效类型字符串，输出 `Error occurred` 即可。

#### 输入格式

第一行包含整数$n$，表示给定单词中 `int` 的数量。

第二行包含若干个单词，每个单词要么是 `pair`，要么是 `int`。

#### 输出格式

输出满足条件的有效类型字符串，如果不存在，则输出 `Error occurred`。

注意，有效类型字符串中**不含**空格或其它多余字符。

#### 数据范围

前 66 个测试点满足：1≤n≤51≤$n$≤5。
所有测试点满足：1≤n≤1051≤$n$≤105，输入的总单词数量不超过 105105，输入的 `int` 数量恰好为 $n$。

#### 输入样例1：

```
3
pair pair int int int
```

#### 输出样例1：

```
pair<pair<int,int>,int>
```

#### 输入样例2：

```
1
pair int
```

#### 输出样例2：

```
Error occurred
```

### 代码

```c++
#include <bits/stdc++.h>

using namespace std;

int n;
string ans;
vector<string> lst;
int idx = -1;

bool dfs()
{
    idx ++ ;
    if (idx >= n) return false;
    auto& t = lst[idx];
    
    if (t[0] == 'p')
    {
        ans += t + "<";
        if (!dfs()) return false;
        ans += ',';
        if (!dfs()) return false;
        ans += '>';
    }
    
    else ans += t;
    return true;
}

int main()
{
    cin >> n;
    string s;
    while (cin >> s) lst.push_back(s);
    n = lst.size();
    
    if (dfs() && idx == n - 1) cout << ans << endl;
    else cout << "Error occurred" << endl;
    
    return 0;
}
```

```c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

string ans;

// 构建二叉树
bool dfs()
{
    char str[5];
    if (scanf("%s", str) == -1) return false;  //内容少了，失败

    if (!strcmp(str, "pair"))  //如果输入的是pair
    {
        ans += str;
        ans += '<';
        if (!dfs()) return false;  //左子树
        ans += ',';
        if (!dfs()) return false;  //右子树
        ans += '>';
    }
    else ans += str;

    return true;
}

int main()
{
    scanf("%*d");

    if (dfs() && scanf("%*s") == -1) puts(ans.c_str());
    else puts("Error occurred");

    return 0;
}
```